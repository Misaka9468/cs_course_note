## Ch6 Locking

本章介绍一种常用的并发控制技术：锁。

锁的缺点是会降低性能，因为它会将并发操作序列化。

### 6.1 Race conditions

race condition: 竞争条件是同时访问内存位置的情况，并且至少有一次访问是写访问.

常见的，解决竞争条件的方法是使用锁。它保证了一段时间内，只能有一个cpu能够访问数据。

被acquire和release包围的部分被称为临界区(critical section).  我们可以将加锁的临界区代码看作是原子性的，其update是统一的、不可拆分的。

如果多个cpu都想要一个锁，这种情况称为conflict，或者cpu遇到了contention.

加锁会导致并行性的丢失，影响了cpu的性能。现代操作系统内核使用复杂的设计来尽量避免lock contention. 比如说，每个cpu都会维护自己的页freelist, 这样kalloc和kfree就不会有多个cpu访问了。

加锁的时机同样重要，如果让acquire提前，会导致并不会引发冲突、可以并行的部分也必须串行处理。

### 6.2 Code: Locks

Xv6有两种锁：spinlocks和sleep-locks. 使用struct spinlock来表示spinlock. 其最重要的成员变量是locked, 如果是0则表示锁是可用的，为非零值则表示锁被占有。

- **acquire的错误实现：**

```c
24 for(;;) {
25     if(lk->locked == 0) {
26         lk->locked = 1;
27         break;
28     }
29 }
```

因为c语言代码没办法保证原子性。可能会出现两个cpu同时执行到第25行。那么同时拥有了锁。因此需要用一些汇编层面的指令操作。

- **acquire的正确实现：**

由于锁的机制过于普遍，因此多核CPU都提供了特殊的指令，来原子性地实现第25和第26行的指令。在RISC-V中，指令是amoswap r, a. 其能够交换寄存器r和地址a对应值。它将原子性地来读写寄存器和内存地址，使用特殊的硬件，从而保证其他cpu不会在此期间读写内存地址。

```
while(__sync_lock_test_and_set(&lk->locked, 1) != 0)
    ;
```

acquire最重要的代码就是上面。其会一直尝试交换lk->locked和1. 该函数返回lk->locked的旧值。

如果旧值为0，那么可知新值为1，锁经历了从空闲到占有的状态，因此结束循环，本cpu拥有锁

如果旧值为1，那么新值也会是1，说明锁一直被占用(为1)，那么我继续循环等待(spinning). 直到旧值为0，这说明其他cpu放回了该锁。__sync_lock_test_and_set最终会调用特殊指令amoswap r, a. 这条特殊指令保证了不会有多个cpu同时读lk->locked, 不可能出现同时读为0的情况。

- **release的正确操作:**

函数release(kernel/spinlock.c:47)与acquire相反：它清除lk->cpu，然后释放锁。 从概念上讲，该版本只需要将零分配给 lk->locked。C 标准允许编译器使用多个存储指令实现赋值，因此 C 赋值对于并发代码而言可能是非原子的。 相反，release 使用执行原子分配的 C 库函数 __sync_lock_release。 这个函数也归结为一条 RISC-V amoswap 指令。

- **硬件究竟是怎么实现这个特殊指令的？具体的实现依赖于内存系统是如何工作的**

一些猜想

1. 多个处理器共用一个内存控制器，内存控制器可以支持这里的操作，比如给一个特定的地址加锁，然后让一个处理器执行2-3个指令，然后再解锁。因为所有的处理器都需要通过这里的内存控制器完成读写，所以内存控制器可以对操作进行排序和加锁。
2. 如果内存位于一个共享的总线上，那么需要总线控制器（bus arbiter）来支持。总线控制器需要以原子的方式执行多个内存操作。
3. 如果处理器有缓存，那么缓存一致性协议会确保对于持有了我们想要更新的数据的cache line只有一个写入者，相应的处理器会对cache line加锁，完成两个操作。

### 6.3 Code: Using locks

Locks in Xv6.

![img](https://picx.zhimg.com/80/v2-648149e4f0d10c63665d70001b926dcb_720w.png?source=d16d100b)

### 6.4 Deadlock and lock ordering

如果在一个代码执行路径中要hold许多锁，那么所有代码执行路径hold锁的顺序应该相同，否则就会发生死锁。经典的死锁场景：进程1有A锁求B锁，进程2有B锁求A锁。这要求整个代码全局，申请锁的顺序应该是相同的。这同样为函数调用增加了要求：调用者应当合理安排调用函数的顺序，使得对锁的申请能够按照指定顺序进行。

Xv6规定了一些锁的申请顺序。比如说consoleintr处理输入字节的中断，其会调用wake up唤醒进程，需要获取进程的锁。因此规定cons.lock必须在任何进程的lock之前被获取；在Xv6中文件系统代码的锁调用链是最长的，必须按照指定顺序来获取锁。

遵守lock ordering是很困难的。有时候，也许代码模块M1要调用M2，但是我们要先获取M2的锁再获取M1的锁。也有时候，我们只有先获取了一个锁，才能知道之后锁的信息。最后，死锁的危险通常是对锁定方案的细粒度的约束，因为更多的锁通常意味着更多的死锁机会。 避免死锁的需要通常是内核实现中的一个主要因素。

### 6.5 Re-entrant locks

可重入锁：如果该锁被一个进程拥有，那么该进程尝试去acquire该锁时，内核应当允许而非panic.

```c
struct spinlock lock;
int data = 0; // protected by lock
f() {
    acquire(&lock);
    if(data == 0){
        call_once(); 
        h();
        data = 1;
    }
    release(&lock);
}
g() {
    aquire(&lock);
    if(data == 0){
        call_once();
        data = 1;
    }
    release(&lock);
}
```

通常情况下，对于该进程call_once只会被调用一次。

- 如果使用了可重入锁，且h()会调用g(), 那么就会调用两次call_once.  
- 如果不使用可重入锁，且()会调用g(), 那么就会死锁。

Xv6不会使用重入锁，原因在于call_once()的重复执行可能会引起隐蔽的错误，宁可死锁然后再解决该问题，并坚信开发者会按照锁的申请流程来编写代码。

### 6.6 Locks and interrupt handlers

在Xv6中，一些锁可能会被线程和中断处理代码同时使用。

试想一个场景：tickslock会被timer interrupt handler和sys_sleep共享，用来对临界数据ticks保护。当sys_sleep拥有该锁，且时钟中断发生时，其会想要申请该锁，然后就会死锁：只有sys_sleep能释放锁，但是cpu现在在处理中断。

解决方法是：当一个锁能被中断处理程序使用时，那么当进程在别的地方拥有该锁时就必须关中断。Xv6做得更严格，当acquire锁之前都会关中断，在release之后才会开中断。

由于锁可能会嵌套. 所以必须要等到外面的锁也被释放了，才可以开中断。Xv6使用push_off和pop_off来对锁的嵌套进行计数。其会调用intr_off and intr_on来开关中断。

注意一定要在lk->locked=1之前就关中断，若反过来，那么两条指令的间隙之间就可能会有中断到来。

### 6.7 Instruction and memory ordering 

cpu并不是一直都是顺序执行指令。许多编译器和 CPU 会乱序执行代码以实现更高的性能。 如果一条指令需要多个周期才能完成，则 CPU 可能会提早发出该指令，以便它可以与其他指令重叠并避免 CPU 停顿。 例如，CPU 可能会注意到在串行指令序列 A 和 B 不相互依赖。 CPU 可能首先启动指令 B，因为它的输入在 A 的输入之前准备就绪，或者为了重叠执行 A 和 B。

但是对于锁来说，如果acquire和release之间的代码被乱序执行，比如放到了acquire和release之后，就会发生问题。因此需要告诉编译器/CPU不要乱序执行被加锁的指令。

在Xv6中的acquire和release实现中，利用__sync_synchronize();实现。两次该函数的调用，就形成了一个屏障。在这两个屏障之间的load, store指令不得乱序执行到屏障外。

### 6.8 Sleep locks

有时 xv6 需要长时间持有锁。例如，文件系统（第 8 章）在磁盘上读取和写入文件内容时保持文件锁定，这些磁盘操作可能需要数十毫秒。如果另一个进程想要获取它，那么长时间持有自旋锁会导致浪费，因为获取进程会在自旋时浪费 CPU 很长时间。

自旋锁的另一个缺点是进程在保留自旋锁的同时不能让出 CPU。我们想这样做，以便其他进程可以使用 CPU，而拥有锁的进程正在等待磁盘。在持有自旋锁时让步是非法的，因为如果第二个线程随后试图获取自旋锁，它可能会导致死锁；由于 acquire 不会让出 CPU，第二个线程的自旋可能会阻止第一个线程运行并释放锁。在持有锁的同时让步也违反了在持有自旋锁时必须关闭中断的要求。因此，我们想要一种在等待获取 CPU 时让出 CPU，并在持有锁时允许让出（和中断）的锁。

Xv6提供了sleep-locks. 它内部由一个spinlock保护，acquiresleep中对sleep的调用，会原子性地yield并且释放spinlock. 因此使得其他线程可以在acquiresleep wait时继续执行。

sleep-locks没有关中断，因此不可以用在中断处理程序中。且在spinlock包围的区域中，不可以再用sleep-lock, 否则可能会yield the CPU.

自旋锁最适合短临界区； 睡眠锁适用于长时间的操作。

### 6.9 Real world

通常最好将锁隐藏在更高级别的构造（如同步队列）中，尽管 xv6 不这样做

大多数操作系统都支持 POSIX 线程 (Pthreads)，它允许用户进程在不同的 CPU 上同时运行多个线程。 Pthreads 支持用户级锁、屏障等。Pthread 还允许程序员有选择地指定锁应该是可重入的。

在用户级别支持 Pthreads 需要操作系统的支持。例如，如果一个 pthread 在系统调用中阻塞，则同一进程的另一个 pthread 应该能够在该 CPU 上运行。再举一个例子，如果一个 pthread 改变了它的进程的地址空间（例如，映射或取消映射内存），内核必须安排其他运行同一进程线程的 CPU 更新它们的硬件页表以反映地址空间的变化。

不使用原子指令也可以实现锁，但代价高昂，而且大多数操作系统都使用原子指令。

为了避免与锁相关的开销，许多操作系统使用无锁数据结构和算法 。例如，可以实现像本章开头那样的链表，它在列表搜索期间不需要锁，并且可以通过一条原子指令在列表中插入一个元素。然而，无锁编程比锁编程更复杂；例如，必须担心指令和内存的重新排序。用锁编程已经很困难了，所以 xv6 避免了无锁编程的额外复杂性。